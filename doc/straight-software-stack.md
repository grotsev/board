Технологический стек, которым мы пользуемся в работе, с течением времени эволюционирует:
* добавляются новые технологии, чтобы принести дополнительные возможности;
* но редко убираются потому, что это требует дополнительных ресурсов.

Получившийся стек имеет системное свойство, что накопленные археологические слои добавляют существенную сложность к необходимым базовым технологиям.

Рефакторинг — это эволюция с поощрением удаления. А лучший рефакторинг — автоматический — когда система делает его сама без участия разработчика.

Прямой стек разработки (Straight Software Stack) стремится сократить число промежуточных технологических слоёв одностраничного Web приложения (Single Page Application, SPA), полагается на автоматизацию, делает "так просто, как только возможно, но не проще", чтобы:
* сократить сроки,
* стоимость проекта,
* улучшить условия труда разработчика.

== Что нужно SPA ==

Приложение должно показывать пользователю свой интерфейс в браузере, реагировать на его действия, отправлять полученные от него данные в хранилище, получать их обратно, взаимодействовать с внешними сервисами.

=== Интерфейс пользователя ===

Интерфейс пользователя можно создавать на клиентской стороне или на серверной. Какой из подходов проще?
* Логика интерфейса проста, когда в ней нет скрытого внутреннего состояния, то есть всё состояние представляется в URL. В этом случае интерфейс проще создавать на сервере.
* В SPA есть внутреннее состояние, например, информация о том, на какой "странице" пользователь находится. В случае сложной логики интерфейс проще создавать на клиенте.

Такие технологии, как JSP, ASP и прочие Pages избыточны и являются археологическими слоями SPA.

Для описания логики в браузере используют JavaScript. Язык быстро развивается, появляются новые возможности, свежие версии языка поддерживаются транспилятором. Но в языке накапливаются археологические слои. Как от них избавиться? Рефакторингом языка, добавив и оставив хорошее и убрав плохое.

Что хорошего в языке должно быть?
* Строгая статическая типизация переводит ошибки из времени запуска во время компиляции. Позволяет уверенно производить рефакторинг, не опасаясь деградации.
* Абстракция (лямбда функция, каррирование) позволяет писать компактный идиоматический код без синтаксического шума, разрабатывать EDSL (встроенные в язык предметно-ориентированные подъязыки)
* Алгебраические типы данных организуют ветвление и гарантируют его полноту, что обработаны все ветки, в том числе ошибочные.
* Иммутабельность упрощает рассуждение о системе, вытесняя изменяющееся состояние изнутри куска кода наружу, в пределе, вовне разрабатываемой подсистемы; положительно влияет на производительность, позволяя компилятору производить хитрые оптимизации без участия разработчика [http://elm-lang.org/blog/blazing-fast-html-round-two].

Что в языке лишнее:
* Динамическая типизация превращает систему в Бородино: "Смешались в кучу кони, люди". Сложно рассуждать.
* ООП предназначено для управления изменяемым состоянием, его инкапсуляцией. Состояние скрыто, но оно есть и неизвестным образом влияет на поведение системы. Сложно рассуждать.

Пример годного языка Elm [http://elm-lang.org/]

=== Хранилище ===

Хранилища имеют большую историю и, казалось бы, должны иметь археологическую нагрузку. Но они подвергались рефакторингу и, поэтому, сейчас они просты, а также производительны и поддерживают большие объёмы данных.

Прорывная технология SQL появился в 1974 году! Почему она прорывная? Потому что система сама, без участия человека может делать рефакторинг — выбирать хороший план исполнения SQL запроса.

Вторая технология — это ACID транзакции. Они гарантируют консистентность — в хранилище лежит то, что туда положили. Может ли быть полезно хранилище, которое выдаёт не то, что нужно? В начале 2000-х развивался подход NoSQL, который обещал большую производительность в обмен на неконсистентность. Такой подход имеет право на существование в области, где данные некритичны (пример многих интернет гигантов). Но отсутствие транзакций не соответствует запросам, например, финансовых приложений. Также оказалось, что производительность можно достичь шардированием как в NoSQL, но не жертвуя консистентностью (CockroachDB, Сitus PostgreSQL). Не нужно забывать и про вертикальное масштабирование: с течением времени оборудование улучшается и новый сервер окажется дешевле разработки.

PostgreSQL взят как самое простое, но много дающее хранилище.

=== Middleware ===

Middleware по определению связывает интерфейс пользователя с хранилищем. Если бы они говорили на одном языке, то средний слой был бы не нужен. Но браузер понимает HTTP, а PostgreSQL понимает SQL. И разработчикам приходится писать middleware — транслятор c HTTP в SQL и обратно, дважды десериализуя и сериализуя изоморфные данные.

PostgREST делает это автоматически. Он даёт REST интерфейс для PostgreSQL, доступный напрямую из браузера по HTTP. PostgREST — это готовый бинарник, поэтому middleware писать просто не нужно.

В служебных целях (безопасность, распределение нагрузки) перед PostgreSQL можно ставить nginx, как преобразователь HTTP в HTTP.

=== Бизнес логика ===

Есть споры относительно того, нужно ли размещать бизнес логику в middleware или в БД, но редко упоминают логику на клиенте. А это самый простой путь с точки зрения разработчика. Потребность в данных (с заданными столбцами, отсортированных в определённом порядке, со связанными сущностями) возникает именно на клиенте, а разработчик вынужден пробрасывать запрос в middleware и далее в БД. На клиенте заманчиво использовать всю мошь SQL, но давать полный доступ небезопасно. Поэтому язык запросов ограничивается DSL на Elm, но со статической типизацией как запросов, так и ответов.

Простая логика, выразимая на DSL, описывается на клиенте, а сложная оборачивается в хранимую процедуру. PL/SQL уже есть в БД, поэтому проще использовать его а не что-то дополнительное. Для выполнения бизнес логики в БД нужно меньше действий, данные ближе, поэтому достижима большая производительность.

=== Внешние сервисы ===

Сложная система обычно не замкнута, а открыта, взаимодействует с внешними сервисами. Источник внешнего взаимодействия может быть:
* Клиентская сторона. Если нужно зафиксировать факт взаимодействия, то клиентский запрос должен попасть в очередь в базе. Например, проверить кредитную историю. Если факт внешнего взаимодействия фиксировать не нужно, то клиент откравляет HTTP запрос напрямую.
* Расписание на сервере, например, отправка SMS.
* Внешний сервис, например, миграция.

Изнутри PostgreSQL в реальном времени данные наружу выходит механизмом LISTEN. Порт, через который данные ходят наружу или вовнутрь пишется отдельно, например, на Java, оформляется в компонент, и может переиспользоваться в других проектах, например, отправка SMS.

== Прямой стек разработки ==

Система разбивается на компоненты, чтобы о ней можно было проще рассуждать. Компоненты общаются между собой на некоторых протоколах. Чем меньше протоколов компонент понимает, тем он проще. В пределе компонент поддерживает только 2 протокола, входной и выходной, которые могут совпадать.

[[Файл:Stack.png]]

На границе системы SPA требуется общаться по внешним протоколам:
* Client, который понимает пользователь: пиксели на экране, нажатия на клавиатуру, движения мышки...
* Server, который понимает оборудование сервера: системные вызовы для работы с диском, сетевой картой...
* External Protocol — семейство протоколов сторонних сервисов: SMS, проверка кредитной истории...

SPA система превращает эти протоколы один в другой через стандартные внутренние протоколы:
* HTML 5, который браузер преобразует в протокол Client;
* HTTP, которым браузер связывается в сторону External Protocol и Server;
* SQL, который PostgreSQL преобразует в протокол Server.

Основные компоненты SPA системы занимаются преобразованием протоколов (по стрелке и обратно):
* Browser : Client -> HTML 5
* Elm : HTML 5 -> HTTP
* PostgREST : HTTP -> SQL
* PostgreSQL : SQL -> Server

Вспомогательные компоненты:
* nginx : HTTP -> HTTP
* семейство port : SQL -> External Protocol для разных внешних протоколов, например SMS

== Ссылки ==

Раздел математики, изучающий, как соединять стрелочки называется Теория категорий.

Страх и ненависть в MiddleWare https://habrahabr.ru/post/331056/
