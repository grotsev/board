Технологический стек, которым мы пользуемся в работе, с течением времени эволюционирует:
* добавляются новые технологии, чтобы принести дополнительные возможности;
* но редко убираются потому, что это требует дополнительных ресурсов.

Получившийся стек имеет системное свойство, что накопленные археологические слои добавляют существенную сложность к необходимым базовым технологиям.

Рефакторинг — это эволюция с поощрением удаления. А лучший рефакторинг — автоматический — когда система делает его сама без участия разработчика.

Прямой стек разработки (Straight Software Stack) стремится сократить число промежуточных технологических слоёв одностраничного Web приложения (Single Page Application, SPA), полагается на автоматизацию, делает "так просто, как только возможно, но не проще", чтобы:
* сократить сроки,
* уменьшить стоимость проекта,
* дать разработчику здоровое понимание и контроль над системой.

[[Файл:Прямые_потоки_данных.gif|800px|center]]

Источник картинки [https://habrahabr.ru/post/331056/ Страх и ненависть в MiddleWare]

== Что нужно SPA ==

Приложение должно показывать пользователю свой интерфейс в браузере, реагировать на его действия, отправлять полученные от него данные в хранилище, получать их обратно, взаимодействовать с внешними сервисами.

=== Интерфейс пользователя ===

Интерфейс пользователя можно создавать на клиентской стороне или на серверной. Какой из подходов проще?
* Логика интерфейса проста, когда в ней нет скрытого внутреннего состояния, то есть всё состояние представляется в URL. В этом случае интерфейс проще создавать на сервере.
* В SPA есть внутреннее состояние, например, информация о том, на какой "странице" пользователь находится. В случае сложной логики интерфейс проще создавать на клиенте.

Такие технологии, как JSP, ASP и прочие Pages избыточны и являются археологическими слоями SPA.

Для описания логики в браузере используют JavaScript. Язык быстро развивается, появляются новые возможности, свежие версии языка поддерживаются транспилятором. Но в языке накапливаются археологические слои. Как от них избавиться? Рефакторингом языка, добавив и оставив хорошее и убрав плохое.

Что хорошего в языке должно быть?
* Строгая статическая типизация переводит ошибки из времени запуска во время компиляции. Позволяет уверенно производить рефакторинг, не опасаясь деградации.
* Абстракция (лямбда функция, каррирование) позволяет писать компактный идиоматический код без синтаксического шума, разрабатывать EDSL (встроенные в язык предметно-ориентированные подъязыки)
* Алгебраические типы данных организуют ветвление и гарантируют его полноту, что обработаны все ветки, в том числе ошибочные.
* Иммутабельность упрощает рассуждение о системе, вытесняя изменяющееся состояние изнутри куска кода наружу, в пределе, вовне разрабатываемой подсистемы; положительно влияет на производительность, позволяя компилятору производить хитрые оптимизации без участия разработчика [http://elm-lang.org/blog/blazing-fast-html-round-two].

Что в языке лишнее:
* Динамическая типизация превращает систему в Бородино: "Смешались в кучу кони, люди". Сложно рассуждать.
* ООП предназначено для управления изменяемым состоянием, его инкапсуляцией. Состояние скрыто, но оно есть и неизвестным образом влияет на поведение системы. Сложно рассуждать.

Пример годного языка Elm [http://elm-lang.org/]

=== Хранилище ===

Хранилища имеют большую историю и, казалось бы, должны иметь археологическую нагрузку. Но они подвергались рефакторингу и, поэтому, сейчас они просты, а также производительны и поддерживают большие объёмы данных.

Прорывная технология SQL появился в 1974 году! Почему она прорывная? Потому что система сама, без участия человека может делать рефакторинг — выбирать хороший план исполнения SQL запроса.

Вторая технология — это ACID транзакции. Они гарантируют консистентность — в хранилище лежит то, что туда положили. Может ли быть полезно хранилище, которое выдаёт не то, что нужно? В начале 2000-х развивался подход NoSQL, который обещал большую производительность в обмен на неконсистентность. Такой подход имеет право на существование в области, где данные некритичны (пример многих интернет гигантов). Но отсутствие транзакций не соответствует запросам, например, финансовых приложений. Также оказалось, что производительность можно достичь шардированием как в NoSQL, но не жертвуя консистентностью (CockroachDB, Сitus PostgreSQL). Не нужно забывать и про вертикальное масштабирование: с течением времени оборудование улучшается и новый сервер окажется дешевле разработки.

PostgreSQL взят как самое простое, но много дающее хранилище.

=== Middleware ===

Middleware по определению связывает интерфейс пользователя с хранилищем. Если бы они говорили на одном языке, то средний слой был бы не нужен. Но браузер понимает HTTP, а PostgreSQL понимает SQL. И разработчикам приходится писать middleware — транслятор c HTTP в SQL и обратно, дважды десериализуя и сериализуя изоморфные данные.

PostgREST делает это автоматически. Он даёт REST интерфейс для PostgreSQL, доступный напрямую из браузера по HTTP. PostgREST — это готовый бинарник, поэтому middleware писать просто не нужно.

В служебных целях (безопасность, распределение нагрузки) перед PostgreSQL можно ставить nginx, как преобразователь HTTP в HTTP.

=== Бизнес логика ===

Есть споры относительно того, нужно ли размещать бизнес логику в middleware или в БД, но редко упоминают логику на клиенте. А это самый простой путь с точки зрения разработчика. Потребность в данных (с заданными столбцами, отсортированных в определённом порядке, со связанными сущностями) возникает именно на клиенте, а разработчик вынужден пробрасывать запрос в middleware и далее в БД. На клиенте заманчиво использовать всю мошь SQL, но давать полный доступ небезопасно. Поэтому язык запросов ограничивается DSL на Elm, но со статической типизацией как запросов, так и ответов.

Простая логика, выразимая на DSL, описывается на клиенте, а сложная оборачивается в хранимую процедуру. PL/SQL уже есть в БД, поэтому проще использовать его а не что-то дополнительное. Для выполнения бизнес логики в БД нужно меньше действий, данные ближе, поэтому достижима большая производительность.

=== Внешние сервисы ===

Сложная система обычно не замкнута, а открыта, взаимодействует с внешними сервисами. Источник внешнего взаимодействия может быть:
* Клиентская сторона. Если нужно зафиксировать факт взаимодействия, то клиентский запрос должен попасть в очередь в базе. Например, проверить кредитную историю. Если факт внешнего взаимодействия фиксировать не нужно, то клиент откравляет HTTP запрос напрямую.
* Расписание на сервере, например, отправка SMS.
* Внешний сервис, например, миграция.

Изнутри PostgreSQL в реальном времени данные наружу выходит механизмом LISTEN. Порт, через который данные ходят наружу или вовнутрь пишется отдельно, например, на Java, оформляется в компонент, и может переиспользоваться в других проектах, например, отправка SMS.

== Прямой стек разработки ==

Система разбивается на компоненты, чтобы о ней можно было проще рассуждать. Компоненты общаются между собой на некоторых протоколах. Чем меньше протоколов компонент понимает, тем он проще. В пределе компонент поддерживает только 2 протокола, входной и выходной, которые могут совпадать.

[[Файл:Stack.png|center]]

На границе системы SPA требуется общаться по внешним протоколам:
* Client, который понимает пользователь: пиксели на экране, нажатия на клавиатуру, движения мышки...
* Server, который понимает оборудование сервера: системные вызовы для работы с диском, сетевой картой...
* External Protocol — семейство протоколов сторонних сервисов: SMS, проверка кредитной истории...

SPA система превращает эти протоколы один в другой через стандартные внутренние протоколы:
* HTML 5, который браузер преобразует в протокол Client;
* HTTP, которым браузер связывается в сторону External Protocol и Server;
* SQL, который PostgreSQL преобразует в протокол Server.

Основные компоненты SPA системы занимаются преобразованием протоколов, по стрелке и обратно ([https://ru.wikipedia.org/wiki/%D0%A2%D0%B5%D0%BE%D1%80%D0%B8%D1%8F_%D0%BA%D0%B0%D1%82%D0%B5%D0%B3%D0%BE%D1%80%D0%B8%D0%B9 как соединять стрелочки]):
* Browser : Client -> HTML 5
* Elm : HTML 5 -> HTTP
* PostgREST : HTTP -> SQL
* PostgreSQL : SQL -> Server

Вспомогательные компоненты:
* nginx : HTTP -> HTTP
* семейство port : SQL -> External Protocol для разных внешних протоколов, например SMS

== Рабочая среда ==

=== Docker ===

[https://docs.docker.com/engine/installation/linux/ubuntu/#install-using-the-repository Инструкция]

 <nowiki>
$ sudo apt-get install \
    apt-transport-https \
    ca-certificates \
    curl \
    software-properties-common
$ curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo apt-key add -
$ sudo add-apt-repository \
   "deb [arch=amd64] https://download.docker.com/linux/ubuntu \
   $(lsb_release -cs) \
   stable"
$ sudo apt-get update
$ sudo apt-get -y install docker-ce</nowiki>

Полезные команды

 <nowiki>
$ docker version
$ sudo docker images
$ sudo docker ps
$ sudo docker inspect NAME
$ sudo docker run OPTIONS
$ sudo docker restart NAME</nowiki>

=== PostgreSQL ===

[https://hub.docker.com/_/postgres/ Инструкция]

Создать контейнер с именем db, базой postgres, паролем суперпользователя 111

 <nowiki>
$ sudo docker run --name db -e POSTGRES_PASSWORD=111 -d postgres</nowiki>

Подсоединиться psql в ещё одном безымянном контейнере из образа postgres к базе в уже запущенном контейнере db

 <nowiki>
$ sudo docker run -it --rm --link db:postgres postgres psql -h postgres -U postgres</nowiki>

Перезагрузить контейнер, в том числе после перезагрузки физического компьютера

 <nowiki>
$ sudo docker restart db</nowiki>

Узнать IP адрес контейнера, чтобы присоединиться через DbVisualizer или DBeaver

 <nowiki>
$ sudo docker inspect db | grep '"IPAddress"'</nowiki>

=== DBeaver ===

Бесплатная и мощная надстройка над Eclipse для просмотра базы, аналог DBVisualizer. [http://dbeaver.jkiss.org/ DBeaver]

=== PostgREST ===

Документация [https://postgrest.com/en/v4.3/]

[https://postgrest.com/en/v0.4/install.html Инструкция] - скачать с гитхаба, разархивировать один бинарник, для удобства поместить бинарник в переменную окружения $PATH, создать конфиг из трёх строк, запустить бинарник с конфигом в аргументе.

 <nowiki>
$ tar zxf postgrest-[version]-[platform].tar.xz

$ ./postgrest --help</nowiki>

Пример postgrest.config

 <nowiki>
# "postgres://user:pass@host:5432/dbname"
db-uri       = "postgres://postgres:111@172.17.0.2:5432/postgres"

# The name of which database schema to expose to REST clients
db-schema    = "scoring"

# The database role to use when no client authentication is provided.
# Can (and probably should) differ from user in db-uri
db-anon-role = "postgres"</nowiki>

Запуск

 <nowiki>
$ postgrest postgrest.config</nowiki>

=== curl ===

curl позволяет из консоли выполнять HTTP запросы.

Тестирование функции login, которая возвращает JWT токен

 <nowiki>
$ curl -X POST -H "Content-Type: application/json" -d '{"login":"den","password":"123456"}' http://localhost:3001/rpc/login</nowiki>

Тестирование выборки из таблицы voting REST сервиса с HTTP заголовком авторизации, который содержит JWT токен

 <nowiki>
$ curl -H "Authorization:Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdGFmZiI6ImYwZjg3NDdhLTk2ZWQtMTFlNy1hMjFkLTkzOGJkY2MyN2YxMiIsInJvbGUiOiJzdGFmZiIsImV4cCI6MTUwNTkxMTE5OH0.lhxemg7tdH7YrytrvwC4sdyXKIX1fwwKtvseFAwwsl0" http://localhost:3001/voting?select=title,voting,period</nowiki>

=== Elm ===

Язык клиентской Web разработки. [http://elm-lang.org/]

Синтаксис языка за полчаса. [http://elm-lang.org/docs/syntax]

Введение в Elm за пару дней. [https://guide.elm-lang.org/]

Стандартная библиотека Elm. [http://package.elm-lang.org/packages/elm-lang/core/latest]

Репозиторий пакетов, включая документацию к ним. [http://package.elm-lang.org/]

Пример архитектуры большого Elm приложения. [https://github.com/rtfeldman/elm-spa-example]

Установка [https://guide.elm-lang.org/install.html]
* elm-repl вычисление Elm выражений
* elm-reactor запуск приложения во время разработки, содержит отладчик путешествия во времени
* elm-make компиляция
* elm-package скачивание пакетов зависимостей из репозитория

 <nowiki>
$ npm install -g elm</nowiki>

Подсказки по коду

 <nowiki>
$ npm install -g elm-oracle</nowiki>

Стандартное форматирование кода

 <nowiki>
$ npm install -g elm-format@exp</nowiki>

=== Sublime Text ===

Редактор кода [https://www.sublimetext.com/]

Установить Package Control [https://packagecontrol.io/installation]

Через него установит Elm Language Support плагин [https://packagecontrol.io/packages/Elm%20Language%20Support]

Рекомендуемые настройки Preferences / Settings
 <nowiki>
{
  "bold_folder_labels": true,
  "highlight_line": true,
  "highlight_modified_tabs": true,
  "preview_on_click": true,
  "tab_size": 2,
  "translate_tabs_to_spaces": true,
  "trim_trailing_white_space_on_save": true
}</nowiki>

== Пример приложения Board ==

Board — это SPA, которое упрощает коммуникации по мелким бизнес-процессам внутри компании, для которых почта менее удобна, например, голосование по подарку ко дню рождения или заказ обеда. На нём обкатывается прямой стек разработки.

=== Структура каталога проекта ===

* '''board/''' корень проекта [http://192.168.11.4/investigation/board/tree/master]
** '''db/''' подпроект базы данных, фактически, вся серверная часть
** '''doc/''' эта документация
** '''elm/''' подпроект веб интерфейса, фактически, вся клиентская часть
** '''etc/''' конфигурация проекта
*** '''postgrest.conf''' конфигурация Postgrest в режиме разработки
** '''.gitignore''' убраны временные файлы сборки, кеша Elm пакетов и elm-repl

==== База данных ====

* '''board/db/''' [http://192.168.11.4/investigation/board/tree/master/db]
** '''build/''' результаты сборки проекта
** '''dev/''' подпроект, собираемый для режима разработки и тестирования
** '''lib/''' подпроект, повторно используемый в нескольких проектах
** '''live/''' подпроект, собираемый для рабочего режима
** '''script/''' скрипты режима разработки для сборки, тестирования, обслуживания компонентов

===== Результаты сборки =====

* '''board/db/build/''' [http://192.168.11.4/investigation/board/tree/master/db/build]
** '''elm/''' сгенерированные Elm файлы, гарантирующие соответствие типов на клиенте и сервере
*** '''Field.elm''' интернационализация названий и описаний столбцов данных и сущностей
*** '''Resource.elm''' описание типов столбцов у таблиц
*** '''Rpc.elm''' описание сигнатуры хранимой процедуры, то есть её типы её аргументов и результата
** '''dev-data.sql''' собранные для режима разработки и тестирования начальные данные: моки
** '''dev-model.sql''' собранные для режима разработки и тестирования DDL создания схемы: вспомогательные и тестовые функции
*** '''live-data.sql''' собранные для рабочего режима начальные данные: интернационализация, значения справочников...
*** '''live-model.sql''' собранные для рабочего режима DDL создания схемы: таблицы, функции...

===== Повторно используемая библиотека =====

* '''board/db/lib/''' [http://192.168.11.4/investigation/board/tree/master/db/lib]
** '''domain/''' DDL создания доменов
*** '''code.sql''' код - предметно-ориентированная константа, подобно элементу перечисления. Строгий формат позволяет конвертировать в разные языки, не опасаясь конфликтов, например, в регистре символов.
*** '''textarea.sql''' многострочный, но ограниченный по длине ввод от пользователя
*** '''textfield.sql''' однострочный и ограниченный по длине ввод от пользователя
*** '''uuid_pk.sql''' автоматически генерируемый идентификатор, подходящий для первичного ключа потому, что возрастает во времени
** '''extension/''' расширения, скопированные со сторонних репозиториев
*** '''pgjwt.sql''' работа с JWT ключами
** '''macro/''' функции, генерирующие SQL или Elm код
*** '''macro_elm_field.sql''' генерация Elm интернационализации названий и описаний столбцов данных и сущностей
** '''table/''' повторно используемые таблицы, ядро схемы проекта
*** '''attr.sql''' атрибуты, колонки
*** '''i18n.sql''' поддерживаемые языки интернационализации
*** '''i18n_attr_help.sql''' перевод описания атрибута
*** '''i18n_attr_title.sql''' перевод названия атрибута
*** '''i18n_rel_help.sql''' перевод описания термина
*** '''i18n_rel_title.sql''' перевод названия термина
*** '''rel.sql''' термин, отношение

===== Рабочий режим =====

* '''board/db/live/''' [http://192.168.11.4/investigation/board/tree/master/db/live]
** '''data/''' начальные данные: интернационализация, значения справочников...
** '''do/''' запуск макросов
** '''function/''' хранимые процедуры с бизнес логикой
** '''grant/''' назначение прав доступа ролям пользователей
** '''table/''' таблицы предметной области
** '''type/''' типы предметной области
** '''init.sql''' инициализация схемы администратором базы данных: создание ролей, расширений, назначение администратора схемы

===== Режим разработки и тестирования =====

* '''board/db/dev/''' [http://192.168.11.4/investigation/board/tree/master/db/dev]
** '''pgbench/''' нагрузочное тестирование
** '''data/''' начальные данные: моки
** '''function/''' вспомогательные хранимые процедуры для тестирования, функции-моки
** '''test/''' модульные и интеграционные тесты
*** '''test_workflow''' модульные и интеграционные тесты [http://pgtap.org/documentation.html pgTAP]
** '''clean.sql''' удаление схемы и пользователей, чтобы можно было произвести заново чистую установку
** '''init.sql''' инициализация тестовой схемы, чтобы не засорять рабочую

===== Скрипты =====

* '''board/db/script/''' [http://192.168.11.4/investigation/board/tree/master/db/script]
** '''assemble.sh''' сборка live и dev .sql файлов модели и начальных данных в порядке, который учитывает зависимости
** '''clean.sh''' удаление схемы из базы
** '''elm-gen.sh''' генерация интерфейсных Elm файлов
** '''install.sh''' установка в базу live и dev схем
** '''rest.sh''' запуск PostgREST
** '''rpc.sh''' тестирование хранимой процедуры через REST
** '''test.sh''' запуск одного или всех модульных тестов автоматически удаляет, пересоздаёт рабочую и тестовую схемы и заполняет их начальными данными, предотвращая работу на "грязной" схеме

==== Веб интерфейс ====

* '''board/elm/''' [http://192.168.11.4/investigation/board/tree/master/elm]
** '''elm-stuff/''' временные файлы
*** '''build-artifacts/''' результаты сборки
*** '''packages/''' кеш пакетов зависимостей
*** '''exact-dependencies.json''' точная версия пакетов зависимостей
** '''src/''' исходный код Elm
** '''elm-package.json''' описание проекта, включая пакеты зависимостей с диапазоном подходящих версий

===== Исходный код Elm =====

* '''board/elm/src''' [http://192.168.11.4/investigation/board/tree/master/elm/src]
** '''Data/''' данные, сериализуемые и десериализуемые при пересылке между клиентом и сервером
** '''I18n/''' перевод текстов в интерфейсе
** '''Page/''' страницы приложения
** '''Main.elm''' точка входа
** '''Route.elm''' типобезопасные маршруты, URL в строке браузера
** '''index.html''' страница для режима разработки

=== Процесс разработки ===

==== База данных ====

===== Добавление таблицы =====

# Добавить одноимённый с таблицей .sql файл в '''board/db/live/table/'''.
# Описать названия столбцов, их типы и ограничения.
# Указать первичный ключ и зависимости по внешним ключам.
# Написать коментарий к таблице и некоторым неоднозначным столбцам.
# Добавить таблицу в секцию '''live_model''' скрипта сборки '''board/db/script/assemble.sh''' с учётом порядка: зависимые таблицы должны быть после независимых.
# Проверить корректность схемы '''$ db/script/test.sh'''.

===== Заполнение таблицы начальными данными =====

# Добавить одноимённый с таблицей .sql файл в '''board/db/live/data/'''.
# В insert указать названия колонок и использовать эту строку как заголовок при выравнивании столбцов.
# В отдельных строках с выравниванием столбцов перечислить записи.
# Добавить таблицу в секцию '''live_data''' скрипта сборки '''board/db/script/assemble.sh''' с учётом порядка: зависимые таблицы должны быть после независимых.
# Проверить корректность схемы '''$ db/script/test.sh'''.

===== Интернационализация таблицы =====

# Добавить таблицу в '''board/db/live/data/rel.sql''' в алфавитном порядке.
# Добавить все новые атрибуты в '''board/db/live/data/attr.sql''' в алфавитном порядке. Колонки с одинаковым именем в разных таблицах считаются одним атрибутом, свободным или связанным по внешнему ключу. Этим предотвращаются коллизии в терминологии. Если встретилась коллизия, можно:
#* переименовать,
#* добавить префикс по имени таблицы,
#* добавить предметно-ориентированный префикс или суффикс.
# Добавить перевод названия таблицы для всех поддерживаемых языков в '''board/db/live/data/i18n_rel_title-* .sql'''.
# Добавить перевод описания таблицы для всех поддерживаемых языков в '''board/db/live/data/i18n_rel_help-* .sql'''.
# Добавить перевод названия атрибутов для всех поддерживаемых языков в '''board/db/live/data/i18n_attr_title-* .sql'''.
# Добавить перевод описания атрибутов для всех поддерживаемых языков в '''board/db/live/data/i18n_attr_help-* .sql'''.
# Проверить полноту интернационализации '''$ db/script/test.sh test_i18n'''.
# Сгенерировать интернационализацию для клиента '''$ db/script/elm-gen.sh'''.

===== Добавление хранимой процедуры =====

# Добавить одноимённый с функцией .sql файл в '''board/db/live/function/'''. Она автоматически добавится в сборку потому, что в секции '''live_model''' скрипта сборки '''board/db/script/assemble.sh''' есть строка '''live/function/* '''.
# Добавить модульный тест хранимой процедуры с префиксом '''test_''' в '''board/db/dev/function'''. Он тоже автоматически добавится в сборку потому, что в секции '''dev_model''' скрипта сборки есть строка '''dev/function/* '''. Модульный тест должен устанавливать права в заголовке '''set role''' функции.
# Запустить модульный тест.
# Добавить права в '''board/db/live/grant/'''.
# Добавить вызов функции в интеграционный тест '''board/db/dev/function/test_workflow.sql'''. Интеграционный тест должен стремиться к максимальному покрытию кода и, как минимум, проходить основной путь бизнес процесса с точки зрения пользователя. Чтобы пройтись по разным путям после ветвления без необходимости повторно создавать сложное состояние удобно пользоваться механизмом '''rollback to savepoint'''. Модульный тест должен менять права, когда с точки зрения пользователя происходит логин.
# Запустить интеграционный тест '''$ db/script/test.sh test_workflow'''.

===== Комит =====

# Запустить все тесты '''$ db/script/test.sh'''.

==== Веб интерфейс ====

===== Начало работы =====

# Перейти в подпроект '''$ cd elm''', установить все зависимости '''$ elm-package install -y''' и вернуться обратно '''$ cd ..'''
# Запустить образ '''pg''' базы данных '''sudo docker restart pg'''.
# Запустить PostgREST и оставить работать в фоне '''$ db/script/rest.sh'''.
# Запустить рабочую среду с путешествующим во времени отладчиком и оставить работать в фоне '''$ elm-reactor'''.
# Открыть в браузере [http://localhost:8000 elm-reactor].
# Перейти в '''src/index.html'''.
# Пощёлкать и попечатать в приложении, открыть '''Explore History''' и попутешествовать во времени.

===== Редактирование в Sublime Edit =====

# Открыть '''board''' в '''File / Open Folder'''.
# Открыть '''board/elm/src/Main.elm'''.
# Проверить ошибки '''Ctrl+B''' в режиме '''Elm Make'''.
# Найти функцию '''main''', перевести курсор на '''Navigation.programWithFlags''', вызвать справку '''Alt+Up''', скрыть справку '''Alt+Down'''.
# Ознакомиться со [https://packagecontrol.io/packages/Elm%20Language%20Support сниппетами]

===== Добавление зависимости =====

# Найти зависимость в [http://package.elm-lang.org/ репозитории], например, '''elm-community/maybe-extra'''.
# Там же ознакомиться с документацией.
# Установить зависимость '''$ elm-package install -y elm-community/maybe-extra'''. Она добавится в '''board/elm/elm-package.json''' и '''board/elm/elm-staff/exact-dependencies.json'''.
# Если обнаружится конфликт версий зависимостей, который проявляется в виде неожиданной ошибки компиляции, то нужно полностью удалить '''board/elm/elm-stuff/''' и переустановить все зависимости '''$ elm-package install -y'''.

===== REST тест хранимой процедуры =====

 <nowiki>
$ db/script/rpc.sh login '{"login":"den","password":"123456"}'</nowiki>

=== Процесс релиза ===

Релиз завершает этап разработки некоторого набора фич. Релиз соответствует переводу с альфа версии в бета версию, то есть внутенняя версия становится доступна заказчику.

Обновление клиента и хранимых процедур не представляет затруднений потому, что в них нет состояния бизнес объектов; нужно просто подменить весь код на новый. Данные в базе являются чистым состоянием и, чтобы их не повредить, требуется особенная забота при обновлении.

Атомарность релиза — желаемое свойство. Тогда можно не волноваться об ошибках при установке.

В Liquibase набор изменений (ChangeSet) концептуально является атомарным. Но пользоваться этим свойством в общем случае не рекомендуется потому, что не все базы данных могут гарантировать атомарность DDL. PostgreSQL может, поэтому релиз пакуется в набор изменений.

Релизы перечисляются в хронологическом порядке в Liquibase логе изменений (ChangeLog). Liquibase тег позволяет именовать релиз.

Схема базы данных, полученная после применения '''live-model.sql''' и '''live-data.sql''' сравнивается с предыдущей схемой, полученной после применения '''changelog.xml'''. Разница фактически является релизом, хотя и требует внимательной проверки.

 <nowiki>
--liquibase formatted sql

--changeset den:1739-origin-model splitStatements:false

--changeset den:1739-origin-data splitStatements:false
</nowiki>

В релизе модель и данные можно разбить на два набора изменений. Чтобы не вспоминать номер предудущего релиза, они именуются в хронологическом порядке по дате: год и неделя в году. Месяц слишком большой период и может накопить очень много релизов, а день даёт шестизначный номер, который сложно читать и запоминать. Рабочий цикл организуется в недели. В отличие от месяца, в неделе всегда 7 дней и их удобно вычитать. Уникальность имени релиза обеспечивает суффикс по имени ветки, фичи или фикса. Имя релиза '''1739-origin''' означает 39 неделю 2017 года на ветке origin. Тестовая схема и данные в релиз не идут.

Кажется, что описание рабочей схемы данных в '''board/db/live/''' и лога изменений в '''changelog.xml''' избыточно. Но они служат разным целям:
* Рабочая схема данных призвана ускорить разработку, так как легко ориентироваться в материализованной в виде файлов схеме данных, свободной от исторической информации.
* Лог изменений предназначен для синхронизации разработанной новой схемы с реальными данными, выполняется только при релизе и не участвует в разработке.

Хранимые процедуры хоть и находятся в базе данных, но не являются состоянием. Поэтому для них используется упрощённый автоматический способ релиза с сокращённым логом изменений: они просто подменяются. Из '''board/db/live/function/''' составляется '''board/db/release/function.sql''', где каждая функция оборачивается в набор изменений

 <nowiki>
--changeset auto:function_name splitStatements:false runOnChange:true</nowiki>

Атрибут '''runOnChange:true''' указывает, что нужно заново применить набор изменений, если текст функции изменился, автор '''auto''', идентификатор совпадает с именем функции. Так как функции подменяются, то они должны быть объявлены '''create or replace'''.

Liquibase поддерживает откат релиза. Но как показывает мировой опыт, эта возможность малополезна и используется очень редко. Здесь она не используется, именно поэтому в логе изменений можно держать только последнюю версию хранимой процедуры.

== Roadmap ==

* Перенести тест интернационализации test_i18n.
* Генерация Elm Data, Rpc, Resource.
* Эволюция схемы данных.
* Детализация распределения прав.
* Индексы таблиц.
