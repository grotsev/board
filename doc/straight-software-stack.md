Технологии, которыми мы пользуемся в разработке, имеют большое влияние на сроки и стоимость проекта, а также на комфортность работы программиста. С течением времени технологии эволюционируют:
* добавляются, чтобы принести новые возможности;
* но редко убираются потому, что это требует дополнительных ресурсов.

Получившийся технологический стек имеет системное свойство, что накопленные взаимосвязанные археологические слои имеют существенную сложность в дополнение к сложности базовых технологий.

Рефакторинг - это эволюция с поощрением удаления. А лучший рефакторинг - автоматический - когда система делает его сама без участия разработчика.

Прямой стек разработки (Straight Software Stack) стремится сократить число промежуточных технологических слоёв одностраничного Web приложения (Single Page Application, SPA), полагаться на автоматизацию, делать "так просто, как только возможно, но не проще".

== Что нужно SPA ==

Приложение должно показывать пользователю свой интерфейс в браузере, реагировать на его действия, отправлять полученные от него данные в хранилище, получать их обратно, возможно, взаимодействовать с внешними сервисами.

=== Интерфейс пользователя ===

Интерфейс пользователя можно создавать на клиентской стороне или на серверной. Какой из подходов проще?

Логика интерфейса проста, когда в ней нет скрытого внутреннего состояния, то есть всё состояние представляется в URL. В этом случае интерфейс проще создавать на сервере.

В SPA есть внутреннее состояние, например, информация о том, на какой "странице" пользователь находится. В случае сложной логики интерфейс проще создавать на клиенте.

Такие технологии, как JSP, ASP и прочие *Pages избыточны и являются археологическими слоями вашего SPA.

Для выполнениея логики браузеры используют JavaScript. Язык быстро развивается, привносятся новые возможности, транспиляторы поддерживают совсем новые версии языка. Но в языке накапливаются археологические слои. Как от них избавиться? С помощью транспилятора из языка, где есть всё хорошее JavaScript и даже больше и нет плохого.

Что хорошего в языке должно быть?
* Строгая статическая типизация переводит ошибки из времени запуска во время компиляции. Позволяет уверенно производить рефакторинг, не опасаясь деградации.
* Абстракция (лямбда функция, каррирование) позволяет писать компактный идиоматический код без синтаксического шума, разрабатывать EDSL (встроенные в язык предметно-ориентированные подъязыки)
* Алгебраические типы данных организуют ветвление и гарантируют его полноту (обработаны все ветки, в том числе ошибочные).
* Иммутабельность упрощает рассуждение о системе, вытесняя изменяющееся состояние изнутри куска кода наружу, в пределе, вовне разрабатываемой системы; положительно влияет на производительность, позволяя компилятору производить хитрые оптимизации без участия разработчика [http://elm-lang.org/blog/blazing-fast-html-round-two].

Что в языке лишнее:
* Динамическая типизация превращает систему в Бородино: "Смешались в кучу кони, люди". Сложно рассуждать.
* ООП предназначено для управления изменяемым состоянием, его инкапсуляцией. Состояние скрыто, но оно есть и неизвестным образом влияет на поведение системы. Сложно рассуждать.

Пример годного языка Elm [http://elm-lang.org/]

=== Хранилище ===

Хранилища имеют большую историю и, казалось бы, должны иметь археологическую нагрузку. Но они подвергались рефакторингу и, поэтому, сейчас они просты, а также производительны и поддерживают большие объёмы данных.

Прорывная технология SQL появился в 1974 году! Почему она прорывная? Потому что система сама, без участия человека может делать рефакторинг - выбирать хороший план исполнения SQL запроса.

Вторая технология - это ACID транзакции. Они гарантируют консистентность - в хранилище лежит то, что туда положили. Может ли быть полезно хранилище, которое выдаёт не то, что надо? В начале 2000-х развивался подход NoSQL, который обещал большую производительность в обмен на неконсистентность. Такой подход имеет право на существование в области, где данные некритичны, смотрите пример многих интернет гигантов. Но отсутствие транзакций не соответствует запросам, например, финансовых приложений. Также оказалось, что производительность можно достичь шардированием как в NoSQL, но не жертвуя консистентностью (CockroachDB, Сitus PostgreSQL).

PostgreSQL взят как самое простое, но много дающее хранилище.

=== Middleware ===

Middleware по определению связывает интерфейс пользователя с хранилищем. Если бы они говорили на одном языке, то средний слой был не нужен. Но браузер понимает HTTP, а PostgreSQL понимает SQL. И программистам приходится писать middleware - транслятор c HTTP в SQL и обратно, дважды десериализуя и сериализуя изоморфные данные.

PostgREST делает это автоматически. Он даёт REST интерфейс для PostgreSQL, доступный напрямую из браузера по HTTP. PostgREST - это готовый бинарник, поэтому middleware писать просто не нужно.

В служебных целях (безопасность, распределение нагрузки) перед PostgreSQL можно ставить Nginx, как преобразователь HTTP в HTTP.

=== Бизнес логика ===

Есть споры относительно того, нужно ли размещать бизнес логику в middleware или в БД, но редко упоминают логику на клиенте. А это самый простой путь с точки зрения разработчика. Потребность в данных (с заданными столбцами, отсортированных в определённом порядке, со связанными сущностями) возникает именно на клиенте, а разработчик вынужден пробрасывать запрос в middleware и далее в БД. На клиенте заманчиво использовать всю мошь SQL, но давать полный доступ небезопасно. Поэтому язык ограничен DSL на Elm, но со статической типизацией как запросов, так и ответов.

Простая логика, которая выразима на DSL описывается на клиенте, а сложная оборачивается в хранимую процедуру. PL/SQL уже есть в БД, поэтому проще использовать его а не что-то дополнительное. Для выполнения бизнес логики в БД нужно меньше действий, данные ближе, поэтому достижима большая производительность.

=== Внешние сервисы ===

Сложная система обычно не замкнута, а открыта, взаимодействует с внешними сервисами. Источник внешнего взаимодействия может быть:
* Клиентская сторона. Если нужно зафиксировать факт взаимодействия, то клиентский запрос должен попасть в очередь в базе. Например, проверить кредитную историю. Если факт внешнего взаимодействия фиксировать не нужно, то клиент откравляет HTTP запрос напрямую.
* Расписание на сервере, например, отправка SMS.
* Внешний сервис, например, миграция.

Изнутри PostgreSQL в реальном времени данные наружу выходит механизмом LISTEN. Компонент, через который данные ходят наружу или вовнутрь пишется отдельно, например, на Java, и может переиспользоваться в других проектах, например, отправка SMS.

== Потоки данных и компоненты ==

== Ссылки ==

Раздел математики, изучающий, как соединять стрелочки называется Теория категорий.

Страх и ненависть в MiddleWare https://habrahabr.ru/post/331056/