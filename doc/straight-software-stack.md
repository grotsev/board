Технологический стек, которым мы пользуемся в работе, с течением времени эволюционирует:
* добавляются новые технологии, чтобы принести дополнительные возможности;
* но редко убираются потому, что это требует дополнительных ресурсов.

Получившийся стек имеет системное свойство, что накопленные археологические слои добавляют существенную сложность к необходимым базовым технологиям.

Рефакторинг — это эволюция с поощрением удаления. А лучший рефакторинг — автоматический — когда система делает его сама без участия разработчика.

Прямой стек разработки (Straight Software Stack) стремится сократить число промежуточных технологических слоёв одностраничного Web приложения (Single Page Application, SPA), полагается на автоматизацию, делает "так просто, как только возможно, но не проще", чтобы:
* сократить сроки,
* стоимость проекта,
* улучшить условия труда разработчика.

== Что нужно SPA ==

Приложение должно показывать пользователю свой интерфейс в браузере, реагировать на его действия, отправлять полученные от него данные в хранилище, получать их обратно, взаимодействовать с внешними сервисами.

=== Интерфейс пользователя ===

Интерфейс пользователя можно создавать на клиентской стороне или на серверной. Какой из подходов проще?
* Логика интерфейса проста, когда в ней нет скрытого внутреннего состояния, то есть всё состояние представляется в URL. В этом случае интерфейс проще создавать на сервере.
* В SPA есть внутреннее состояние, например, информация о том, на какой "странице" пользователь находится. В случае сложной логики интерфейс проще создавать на клиенте.

Такие технологии, как JSP, ASP и прочие Pages избыточны и являются археологическими слоями SPA.

Для описания логики в браузере используют JavaScript. Язык быстро развивается, появляются новые возможности, свежие версии языка поддерживаются транспилятором. Но в языке накапливаются археологические слои. Как от них избавиться? Рефакторингом языка, добавив и оставив хорошее и убрав плохое.

Что хорошего в языке должно быть?
* Строгая статическая типизация переводит ошибки из времени запуска во время компиляции. Позволяет уверенно производить рефакторинг, не опасаясь деградации.
* Абстракция (лямбда функция, каррирование) позволяет писать компактный идиоматический код без синтаксического шума, разрабатывать EDSL (встроенные в язык предметно-ориентированные подъязыки)
* Алгебраические типы данных организуют ветвление и гарантируют его полноту, что обработаны все ветки, в том числе ошибочные.
* Иммутабельность упрощает рассуждение о системе, вытесняя изменяющееся состояние изнутри куска кода наружу, в пределе, вовне разрабатываемой подсистемы; положительно влияет на производительность, позволяя компилятору производить хитрые оптимизации без участия разработчика [http://elm-lang.org/blog/blazing-fast-html-round-two].

Что в языке лишнее:
* Динамическая типизация превращает систему в Бородино: "Смешались в кучу кони, люди". Сложно рассуждать.
* ООП предназначено для управления изменяемым состоянием, его инкапсуляцией. Состояние скрыто, но оно есть и неизвестным образом влияет на поведение системы. Сложно рассуждать.

Пример годного языка Elm [http://elm-lang.org/]

=== Хранилище ===

Хранилища имеют большую историю и, казалось бы, должны иметь археологическую нагрузку. Но они подвергались рефакторингу и, поэтому, сейчас они просты, а также производительны и поддерживают большие объёмы данных.

Прорывная технология SQL появился в 1974 году! Почему она прорывная? Потому что система сама, без участия человека может делать рефакторинг — выбирать хороший план исполнения SQL запроса.

Вторая технология — это ACID транзакции. Они гарантируют консистентность — в хранилище лежит то, что туда положили. Может ли быть полезно хранилище, которое выдаёт не то, что нужно? В начале 2000-х развивался подход NoSQL, который обещал большую производительность в обмен на неконсистентность. Такой подход имеет право на существование в области, где данные некритичны (пример многих интернет гигантов). Но отсутствие транзакций не соответствует запросам, например, финансовых приложений. Также оказалось, что производительность можно достичь шардированием как в NoSQL, но не жертвуя консистентностью (CockroachDB, Сitus PostgreSQL). Не нужно забывать и про вертикальное масштабирование: с течением времени оборудование улучшается и новый сервер окажется дешевле разработки.

PostgreSQL взят как самое простое, но много дающее хранилище.

=== Middleware ===

Middleware по определению связывает интерфейс пользователя с хранилищем. Если бы они говорили на одном языке, то средний слой был бы не нужен. Но браузер понимает HTTP, а PostgreSQL понимает SQL. И разработчикам приходится писать middleware — транслятор c HTTP в SQL и обратно, дважды десериализуя и сериализуя изоморфные данные.

PostgREST делает это автоматически. Он даёт REST интерфейс для PostgreSQL, доступный напрямую из браузера по HTTP. PostgREST — это готовый бинарник, поэтому middleware писать просто не нужно.

В служебных целях (безопасность, распределение нагрузки) перед PostgreSQL можно ставить nginx, как преобразователь HTTP в HTTP.

=== Бизнес логика ===

Есть споры относительно того, нужно ли размещать бизнес логику в middleware или в БД, но редко упоминают логику на клиенте. А это самый простой путь с точки зрения разработчика. Потребность в данных (с заданными столбцами, отсортированных в определённом порядке, со связанными сущностями) возникает именно на клиенте, а разработчик вынужден пробрасывать запрос в middleware и далее в БД. На клиенте заманчиво использовать всю мошь SQL, но давать полный доступ небезопасно. Поэтому язык запросов ограничивается DSL на Elm, но со статической типизацией как запросов, так и ответов.

Простая логика, выразимая на DSL, описывается на клиенте, а сложная оборачивается в хранимую процедуру. PL/SQL уже есть в БД, поэтому проще использовать его а не что-то дополнительное. Для выполнения бизнес логики в БД нужно меньше действий, данные ближе, поэтому достижима большая производительность.

=== Внешние сервисы ===

Сложная система обычно не замкнута, а открыта, взаимодействует с внешними сервисами. Источник внешнего взаимодействия может быть:
* Клиентская сторона. Если нужно зафиксировать факт взаимодействия, то клиентский запрос должен попасть в очередь в базе. Например, проверить кредитную историю. Если факт внешнего взаимодействия фиксировать не нужно, то клиент откравляет HTTP запрос напрямую.
* Расписание на сервере, например, отправка SMS.
* Внешний сервис, например, миграция.

Изнутри PostgreSQL в реальном времени данные наружу выходит механизмом LISTEN. Порт, через который данные ходят наружу или вовнутрь пишется отдельно, например, на Java, оформляется в компонент, и может переиспользоваться в других проектах, например, отправка SMS.

== Прямой стек разработки ==

Система разбивается на компоненты, чтобы о ней можно было проще рассуждать. Компоненты общаются между собой на некоторых протоколах. Чем меньше протоколов компонент понимает, тем он проще. В пределе компонент поддерживает только 2 протокола, входной и выходной, которые могут совпадать.

[[Файл:Stack.png]]

На границе системы SPA требуется общаться по внешним протоколам:
* Client, который понимает пользователь: пиксели на экране, нажатия на клавиатуру, движения мышки...
* Server, который понимает оборудование сервера: системные вызовы для работы с диском, сетевой картой...
* External Protocol — семейство протоколов сторонних сервисов: SMS, проверка кредитной истории...

SPA система превращает эти протоколы один в другой через стандартные внутренние протоколы:
* HTML 5, который браузер преобразует в протокол Client;
* HTTP, которым браузер связывается в сторону External Protocol и Server;
* SQL, который PostgreSQL преобразует в протокол Server.

Основные компоненты SPA системы занимаются преобразованием протоколов (по стрелке и обратно):
* Browser : Client -> HTML 5
* Elm : HTML 5 -> HTTP
* PostgREST : HTTP -> SQL
* PostgreSQL : SQL -> Server

Вспомогательные компоненты:
* nginx : HTTP -> HTTP
* семейство port : SQL -> External Protocol для разных внешних протоколов, например SMS

== Рабочая среда ==

=== Docker ===

[https://docs.docker.com/engine/installation/linux/ubuntu/#install-using-the-repository Инструкция]

 <nowiki>
$ sudo apt-get install \
    apt-transport-https \
    ca-certificates \
    curl \
    software-properties-common
$ curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo apt-key add -
$ sudo add-apt-repository \
   "deb [arch=amd64] https://download.docker.com/linux/ubuntu \
   $(lsb_release -cs) \
   stable"
$ sudo apt-get update
$ sudo apt-get -y install docker-ce</nowiki>

Полезные команды

 <nowiki>
$ docker version
$ sudo docker images
$ sudo docker ps
$ sudo docker inspect NAME
$ sudo docker run OPTIONS
$ sudo docker restart NAME</nowiki>

=== PostgreSQL ===

[https://hub.docker.com/_/postgres/ Инструкция]

Создать контейнер с именем db, базой postgres, паролем суперпользователя 111

 <nowiki>
$ sudo docker run --name db -e POSTGRES_PASSWORD=111 -d postgres</nowiki>

Подсоединиться psql в ещё одном безымянном контейнере из образа postgres к базе в уже запущенном контейнере db

 <nowiki>
$ sudo docker run -it --rm --link db:postgres postgres psql -h postgres -U postgres</nowiki>

Перезагрузить контейнер, в том числе после перезагрузки физического компьютера

 <nowiki>
$ sudo docker restart db</nowiki>

Узнать IP адрес контейнера, чтобы присоединиться через DbVisualizer или DBeaver

 <nowiki>
$ sudo docker inspect db | grep '"IPAddress"'</nowiki>

=== DBeaver ===

Бесплатная и мощная надстройка над Eclipse для просмотра базы, аналог DBVisualizer. [http://dbeaver.jkiss.org/ DBeaver]

=== PostgREST ===

Документация [https://postgrest.com/en/v4.3/]

[https://postgrest.com/en/v0.4/install.html Инструкция] - скачать с гитхаба, разархивировать один бинарник, для удобства поместить бинарник в переменную окружения $PATH, создать конфиг из трёх строк, запустить бинарник с конфигом в аргументе.

 <nowiki>
$ tar zxf postgrest-[version]-[platform].tar.xz

$ ./postgrest --help</nowiki>

Пример postgrest.config

 <nowiki>
# "postgres://user:pass@host:5432/dbname"
db-uri       = "postgres://postgres:111@172.17.0.2:5432/postgres"

# The name of which database schema to expose to REST clients
db-schema    = "scoring"

# The database role to use when no client authentication is provided.
# Can (and probably should) differ from user in db-uri
db-anon-role = "postgres"</nowiki>

Запуск

 <nowiki>
$ postgrest postgrest.config</nowiki>

=== curl ===

curl позволяет из консоли выполнять HTTP запросы.

Тестирование функции login, которая возвращает JWT токен

 <nowiki>
$ curl -X POST -H "Content-Type: application/json" -d '{"login":"den","password":"123456"}' http://localhost:3001/rpc/login</nowiki>

Тестирование выборки из таблицы voting REST сервиса с HTTP заголовком авторизации, который содержит JWT токен

 <nowiki>
$ curl -H "Authorization:Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdGFmZiI6ImYwZjg3NDdhLTk2ZWQtMTFlNy1hMjFkLTkzOGJkY2MyN2YxMiIsInJvbGUiOiJzdGFmZiIsImV4cCI6MTUwNTkxMTE5OH0.lhxemg7tdH7YrytrvwC4sdyXKIX1fwwKtvseFAwwsl0" http://localhost:3001/voting?select=title,voting,period</nowiki>

=== Elm ===

Язык клиентской Web разработки. [http://elm-lang.org/]

Синтаксис языка за полчаса. [http://elm-lang.org/docs/syntax]

Введение в Elm за пару дней. [https://guide.elm-lang.org/]

Стандартная библиотека Elm. [http://package.elm-lang.org/packages/elm-lang/core/latest]

Репозиторий пакетов, включая документацию к ним. [http://package.elm-lang.org/]

Пример архитектуры большого Elm приложения. [https://github.com/rtfeldman/elm-spa-example]

Установка [https://guide.elm-lang.org/install.html]
* elm-repl вычисление Elm выражений
* elm-reactor запуск приложения во время разработки, содержит отладчик путешествия во времени
* elm-make компиляция
* elm-package скачивание пакетов зависимостей из репозитория

 <nowiki>
$ npm install -g elm</nowiki>

Подсказки по коду

 <nowiki>
$ npm install -g elm-oracle</nowiki>

Стандартное форматирование кода

 <nowiki>
$ npm install -g elm-format@exp</nowiki>

=== Sublime Text ===

Редактор кода [https://www.sublimetext.com/]

Установить Package Control [https://packagecontrol.io/installation]

Через него установит Elm Language Support плагин [https://packagecontrol.io/packages/Elm%20Language%20Support]

Рекомендуемые настройки Preferences / Settings
 <nowiki>
{
  "bold_folder_labels": true,
  "highlight_line": true,
  "highlight_modified_tabs": true,
  "preview_on_click": true,
  "tab_size": 2,
  "translate_tabs_to_spaces": true,
  "trim_trailing_white_space_on_save": true
}</nowiki>

== Пример приложения Board ==

Board — это SPA, которое упрощает коммуникации по мелким бизнес-процессам внутри компании, для которых почта менее удобна, например, голосование по подарку ко дню рождения или заказ обеда. На нём обкатывается прямой стек разработки.

=== Структура каталога проекта ===

* '''board/''' корень проекта [http://192.168.11.4/investigation/board/tree/master]
** '''db/''' подпроект базы данных, фактически, вся серверная часть
** '''doc/''' эта документация
** '''elm/''' подпроект веб интерфейса, фактически, вся клиентская часть
** '''etc/''' конфигурация проекта
*** '''postgrest.conf''' конфигурация Postgrest в режиме разработки
** '''.gitignore''' убраны временные файлы сборки, кеша Elm пакетов и elm-repl

==== База данных ====

* '''board/db/''' [http://192.168.11.4/investigation/board/tree/master/db]
** '''build/''' результаты сборки проекта
** '''dev/''' подпроект, собираемый для режима разработки и тестирования
** '''lib/''' подпроект, повторно используемый в нескольких проектах
** '''live/''' подпроект, собираемый для рабочего режима
** '''script/''' скрипты режима разработки для сборки, тестирования, обслуживания компонентов

===== Результаты сборки =====

* '''board/db/build/''' [http://192.168.11.4/investigation/board/tree/master/db/build]
** '''elm/''' сгенерированные Elm файлы, гарантирующие соответствие типов на клиенте и сервере
*** '''Field.elm''' интернационализация названий и описаний столбцов данных и сущностей
*** '''Resource.elm''' описание типов столбцов у таблиц
*** '''Rpc.elm''' описание сигнатуры хранимой процедуры, то есть её типы её аргументов и результата
** '''dev-data.sql''' собранные для режима разработки и тестирования начальные данные: моки
** '''dev-model.sql''' собранные для режима разработки и тестирования DDL создания схемы: вспомогательные и тестовые функции
*** '''live-data.sql''' собранные для рабочего режима начальные данные: интернационализация, значения справочников...
*** '''live-model.sql''' собранные для рабочего режима DDL создания схемы: таблицы, функции...

===== Повторно используемая библиотека =====

* '''board/db/lib/''' [http://192.168.11.4/investigation/board/tree/master/db/lib]
** '''domain/''' DDL создания доменов
*** '''code.sql''' код - предметно-ориентированная константа, подобно элементу перечисления. Строгий формат позволяет конвертировать в разные языки, не опасаясь конфликтов, например, в регистре символов.
*** '''textarea.sql''' многострочный, но ограниченный по длине ввод от пользователя
*** '''textfield.sql''' однострочный и ограниченный по длине ввод от пользователя
*** '''uuid_pk.sql''' автоматически генерируемый идентификатор, подходящий для первичного ключа потому, что возрастает во времени
** '''extension/''' расширения, скопированные со сторонних репозиториев
*** '''pgjwt.sql''' работа с JWT ключами
** '''macro/''' функции, генерирующие SQL или Elm код
*** '''macro_elm_field.sql''' генерация Elm интернационализации названий и описаний столбцов данных и сущностей
** '''table/''' повторно используемые таблицы, ядро схемы проекта
*** '''attr.sql''' атрибуты, колонки
*** '''i18n.sql''' поддерживаемые языки интернационализации
*** '''i18n_attr_help.sql''' перевод описания атрибута
*** '''i18n_attr_title.sql''' перевод названия атрибута
*** '''i18n_rel_help.sql''' перевод описания термина
*** '''i18n_rel_title.sql''' перевод названия термина
*** '''rel.sql''' термин, отношение

===== Рабочий режим =====

* '''board/db/live/''' [http://192.168.11.4/investigation/board/tree/master/db/live]
** '''data/''' начальные данные: интернационализация, значения справочников...
** '''do/''' запуск макросов
** '''function/''' хранимые процедуры с бизнес логикой
** '''grant/''' назначение прав доступа ролям пользователей
** '''table/''' таблицы предметной области
** '''type/''' типы предметной области
** '''init.sql''' инициализация схемы администратором базы данных: создание ролей, расширений, назначение администратора схемы

===== Режим разработки и тестирования =====

* '''board/db/dev/''' [http://192.168.11.4/investigation/board/tree/master/db/dev]
** '''pgbench/''' нагрузочное тестирование
** '''data/''' начальные данные: моки
** '''function/''' вспомогательные хранимые процедуры для тестирования, функции-моки
** '''test/''' модульные и интеграционные тесты
*** '''test_workflow''' модульные и интеграционные тесты [http://pgtap.org/documentation.html pgTAP]
** '''clean.sql''' удаление схемы и пользователей, чтобы можно было произвести заново чистую установку
** '''init.sql''' инициализация тестовой схемы, чтобы не засорять рабочую

===== Скрипты =====

* '''board/db/script/''' [http://192.168.11.4/investigation/board/tree/master/db/script]
** '''assemble.sh''' сборка live и dev .sql файлов модели и начальных данных
** '''clean.sh''' удаление схемы из базы
** '''elm-gen.sh''' генерация интерфейсных Elm файлов
** '''install.sh''' установка в базу live и dev схем
** '''rest.sh''' запуск PostgREST
** '''rpc.sh''' тестирование хранимой процедуры через REST
** '''test.sh''' запуск одного или всех модульных тестов

==== Веб интерфейс ====

== Ссылки ==

Раздел математики, изучающий, как соединять стрелочки называется "Теория категорий".

Страх и ненависть в MiddleWare https://habrahabr.ru/post/331056/
